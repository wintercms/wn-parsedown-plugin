<?php

namespace Winter\Parsedown\Classes;

use Winter\Storm\Parse\MarkdownData;
use Winter\Storm\Support\Facades\Event;

/**
 * Markdown helper class.
 *
 * Calling Markdown::parse($text) returns the HTML corresponding
 * to the Markdown input in $text.
 *
 * WinterCMS uses ParsedownExtra as its Markdown parser,
 * but fires markdown.beforeParse and markdown.parse events
 * allowing hooks into the default parsing,
 *
 * The markdown.beforeParse event passes a MarkdownData
 * instance, containing a public $text variable. Event
 * listeners can modify $text, for example to filter out
 * or protect snippets from being interpreted by ParseDown.
 *
 * Similarly, markdown.parse is fired after ParseDown has
 * interpreted the (possibly modified) input. This event
 * passes an array [$text, $data], where $text is the
 * original unmodified Markdown input, and $data is the HTML
 * code generated by ParseDown.
 *
 * NOTE: This class has been slightly modified to provide stubs for new
 * Markdown parsing API in Winter Storm with the CommonMark library.
 * This should allow the class to be API-compatible, but the stubs will
 * have no effect on Parsedown usage.
 *
 * @author Alexey Bobkov, Samuel Georges
 **/
class Markdown
{
    use \Winter\Storm\Support\Traits\Emitter;

    /**
     * Parsedown class
     */
    protected string $parserClass = \Winter\Parsedown\Classes\Parsedown::class;

    /**
     * Gets an instance of the parser.
     *
     * We return a new instance each time to prevent contamination of clean instances.
     */
    protected function getParser($environment = null): Parsedown
    {
        return new $this->parserClass;
    }

    /**
     * Sets the Markdown parser.
     */
    public function setParser(string|object $parserClass): void
    {
        if (is_object($parserClass)) {
            $this->parserClass = get_class($parserClass);
        } else {
            $this->parserClass = $parserClass;
        }
    }

    /**
     * Parse text using Markdown and Markdown-Extra
     * @param string $text Markdown text to parse
     * @return string Resulting HTML
     */
    public function parse(string $text): string
    {
        return $this->parseInternal($text);
    }

    /**
     * Enables safe mode
     * @param  string $text Markdown text to parse
     * @return string       Resulting HTML
     */
    public function parseClean(string $text): string
    {
        $parser = $this->getParser()->setSafeMode(true);

        return $this->parseInternal($text, 'text', $parser);
    }

    /**
     * Disables code blocks caused by indentation.
     * @param  string $text Markdown text to parse
     * @return string       Resulting HTML
     */
    public function parseSafe(string $text): string
    {
        $parser = $this->getParser()->setUnmarkedBlockTypes([]);

        return $this->parseInternal($text, 'text', $parser);
    }

    /**
     * Parse a single line
     * @param  string $text Markdown text to parse
     * @return string       Resulting HTML
     */
    public function parseLine(string $text): string
    {
        return $this->parseInternal($text, 'line');
    }

    /**
     * Internal method for parsing
     */
    protected function parseInternal(string $text, string $method = 'text', Parsedown $parser = null): string
    {
        if (is_null($parser)) {
            $parser = $this->getParser();
        }
        $data = new MarkdownData($text);

        $this->fireEvent('beforeParse', [$data], false);
        Event::fire('markdown.beforeParse', [$data], false);

        $result = $data->text;

        $result = $parser->$method($result);

        $data->text = $result;

        // The markdown.parse gets passed both the original
        // input and the result so far.
        $this->fireEvent('parse', [$text, $data], false);
        Event::fire('markdown.parse', [$text, $data], false);

        return $data->text;
    }

    // The following methods are stubs for the new Markdown API. They have no effect
    // on Parsedown usage.

    /**
     * Stub out new `getFrontMatter()` method.
     */
    public function getFrontMatter(): array
    {
        return [];
    }

    /**
     * Stub out new `getRenderer()` method.
     */
    public function setRenderer(\League\CommonMark\Renderer\DocumentRendererInterface $renderer): void
    {
        return;
    }

    /**
     * Stub out fluent configuration.
     */
    public function __call(string $name, array $arguments): static
    {
        if (
            str_starts_with($name, 'set')
            || str_starts_with($name, 'enable')
            || str_starts_with($name, 'disable')
        ) {
            return $this;
        }

        throw new \BadMethodCallException(sprintf('Call to undefined method %s::%s()', static::class, $name));
    }

    /**
     * Stub out fluent static configuration.
     */
    public static function __callStatic(string $name, array $arguments): static
    {

        if (
            str_starts_with($name, 'set')
            || str_starts_with($name, 'enable')
            || str_starts_with($name, 'disable')
        ) {
            $instance = new static;
            return $instance;
        }

        throw new \BadMethodCallException(sprintf('Call to undefined method %s::%s()', static::class, $name));
    }
}
